"""
    Tropical Cyclone Risk Model (TCRM) - Version 1.0 (beta release)
    Copyright (C) 2011 Commonwealth of Australia (Geoscience Australia)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.


Title: SamplingOrigin.py

Author: Geoff Xu, geoff.xu@ga.gov.au
CreationDate: 2006-01-16
Description: Define the class for sampling cyconle origins. Python code
              developed from Xun Guo Lin's MATLAB code on sampling of
              cyclone origins

Version: $Rev: 810 $

ModifiedDate: 2006-10-31
ModifiedBy: C. Arthur
Modifications: Added descriptive headers and metadata

ModifiedDate: 2006-11-29
ModifiedBy: N. Habili
Modifications: File names passed by dictionaries instead of individual
               file names.
               Upgrade to ndarray
               Conformance with style guide

ModifiedDate: 2007-04-02
ModifiedBy: N. Habili
Modifications: Added setKDEOrigins

Version: 83
ModifiedBy: Craig Arthur, craig.arthur@ga.gov.au
ModifiedDate: 10/04/08 11:42:AM
Modification: Changed logging method

Version: $Rev: 810 $
ModifiedBy: Craig Arthur, craig.arthur@ga.gov.au
ModifiedDate: 2008-07-02 2:35:PM
Modification: Reads the origin PDF data from an ascii grid format file

$Id: SamplingOrigin.py 810 2012-02-21 07:52:50Z nsummons $
"""

import os, sys, pdb, logging

import time
from Utilities.files import flLoadFile, flSaveFile
from Utilities.grid import grdRead, grdReadFromNetcdf
from scipy import array, zeros, rand, empty, ndarray, transpose
import Utilities.stats as stats
from Utilities.config import ConfigParser

class SamplingOrigin:
    """
    Parameters
    ----------
    files : dictionary
        dictionary containing input/output file names and paths.
    ns : integer
        number of samples to generate

    Members
    -------
    kdeOriginX : 1D array of float
        x coordinates of kde result generated from KDEOrigin class
    kdeOriginY : 1D array of float
        y coordinates of kde result generated from KDEOrigin class
    kdeOriginZ : 1D array of float
        z coordinates of kde result generated from KDEOrigin class
    ns : int
        number of samples to generate
    cdfX : 2D array of float
        cumulative density function in longitudinal direction
    cdfY : 2D array of float
        cumulative density function in latitudinal direction

    Methods
    -------
    generateSamples(ns,sample_orig_path)
        generate random samples of cyclone initial origins

    generateOneSample() : float, float
        generate a random sample of cyclone initial origin

    plotContours(aus_coast_line,oricounts,lon_bin,lat_bin)
        plot the contours of historical cyclone origins,
        cyclone origins estimated by 2D KDE,
        and cyclone origins generated by random sampling

    Internal Methods
    -------
    calculateCDF()
        calculate Py and CDFy beforehand to remove the need of repeated
        calculation later

    Accessor Methods
    ----------------
    setKDEOrigins(kdeOriginX, kdeOriginY, kdeOriginZ, files) : string or
        array set parameters

    """

    def __init__(self, kdeOrigin=None, x=None, y=None):
        """
        Initialise the array of probabilities of genesis, plus the
        lon/lat arrays.
        """
        self.logger=logging.getLogger()

        if type(kdeOrigin) == str:
            self.logger.debug("Loading PDF from %s"%kdeOrigin)
            try:
                if kdeOrigin.endswith('nc'):
                    self.x, self.y, self.z = grdReadFromNetcdf(kdeOrigin)
                else:
                    self.x, self.y, self.z = grdRead(kdeOrigin)
            except IOError:
                self.logger.critical('Error! Files relating to cdf of cyclone parameters does not exist, please generate KDE of cyclone parameters first.')
                raise
            self._calculateCDF()  # calculate CDF of (x,Px) and (y,Py)
        elif type(kdeOrigin) == ndarray:
            self.x = x
            self.y = y
            self.z = kdeOrigin
            self._calculateCDF()  # calculate CDF of (x,Px) and (y,Py)
        else:
            self.x = array([])
            self.y = array([])
            self.z = array([])

    def __doc__(self):
        """
Documentation on the purpose of the class
        """

        return 'Tropical cyclone origin sampling: \
                Generate a single or multiple TC origins, based on the \
                probability of genesis (assumed generated from a KDE of \
                historic genesis locations, but could be any other source)'

    def setKDEOrigins(self, kdeOriginX=None, kdeOriginY=None, kdeOriginZ=None,
                      outputPath=None):
        """set kde origin parameters
        """
        if outputPath:
            try:
                self.x, self.y. self.z = grdRead(os.path.join(self.outputPath,
                                                              'originPDF.txt'))
            except IOError:
                self.logger.critical('Error! Files relating to KDE of cyclone origins does not exist. Execute KDE of cyclone origins first.')
                raise
            self._calculateCDF() #calculate CDF of (x,Px) and (y,Py)
        elif type(kdeOriginZ) == str:
            try:
                self.x = flLoadFile(kdeOriginX)
                self.y = flLoadFile(kdeOriginY)
                self.z = flLoadFile(kdeOriginZ)
            except IOError:
                self.logger.critical('Error! Files relating to CDF of cyclone parameters do not exist. Generate KDE of cyclone parameters first.')
                raise
            self._calculateCDF()  # calculate CDF of (x,Px) and (y,Py)
        elif type(kdeOriginZ) == ndarray:
            self.x, self.y, self.z = grdRead(kdeOriginZ)
            self._calculateCDF()  # calculate CDF of (x,Px) and (y,Py)
        else:
            self.logger.error("No input arguments")
            raise

    def generateOneSample(self):
        """Generate a random cyclone origin"""
        # generate 2 uniform random variables
        unifX = rand()
        unifY = rand()

        xi = array(self.cdfX).searchsorted(unifX)
        yj = self.cdfY[xi, :].searchsorted(unifY)

        return self.x[xi], self.y[yj] #lon, lat

    def ppf(self, q1, q2):
        xi = self.cdfX.searchsorted(q1)
        yj = self.cdfY[xi, :].searchsorted(q2)
        return self.x[xi], self.y[yj] #lon, lat

    def cdf(self, x, y):
        # crude, this should be an interpolation
        xi = self.x.searchsorted(x) - 1
        yi = self.y.searchsorted(y) - 1
        return self.cdfX[xi], self.cdfY[xi, yi]

    def generateSamples(self, ns, outputFile=None):
        """Generate random samples of cyclone origins"""
        if ns <= 0:
            self.logger.error('Invalid input on ns: number of sample cannot be zero or negative')
            raise ValueError

        # Generate 2 vectors of uniform random variables
        unifX = rand(ns)
        unifY = rand(ns)

        self.oLon = empty(ns, 'd')
        self.oLat = empty(ns, 'd')

        # For each random variable
        try:
            for i in xrange(ns):
                xi = self.cdfX.searchsorted(unifX[i])
                yj = self.cdfY[xi, :].searchsorted(unifY[i])
                if (i % (ns/100)) == 0 and i != 0:
                    self.logger.debug("Processing %ith element"%i)
                self.oLon[i] = self.x[xi]
                self.oLat[i] = self.y[yj]

        except IndexError:
            self.logger.debug("i = %s"%str(i))
            self.logger.debug("unifX = %s"%str(unifX[i]))
            self.logger.debug("unifY = %s"%str(unifY[i]))
            self.logger.debug("cdfY[xi,:] = %s"%str(self.cdfY[xi, :]))
            raise

        if outputFile:
            flSaveFile(outputFile, transpose([self.oLon, self.oLat]),
                       fmt='%2.3f', header='Origin Lon, Origin Lat',
                       delimiter=',')
        else:
            lonLat = empty([ns, 2], 'd')
            lonLat[:, 0] = self.oLon
            lonLat[:, 1] = self.oLat
            return lonLat

    def _calculateCDF(self):
        """Calculate Py and CDFy beforehand to remove the need of
        repeated calculation later
        """
        # sum along the column of z to get sum(z(i,:))
        # (check 'help sum' if need)
        px =  self.z.sum(axis=0)
        # calculate CDF of (x,Px)
        cdfX = stats.cdf(self.x, px)
        # define Py & CDFy with nx by ny
        py = zeros([self.x.size, self.y.size], 'd')
        cdfY = zeros([self.x.size, self.y.size], 'd')
        # Py=conditional distribution,  CDFy = CDF of Y
        try:
            for i in xrange(len(self.x)):
                for j in xrange(len(self.z[:, i])):
                    if px[i] == 0:
                        py[i,j] = 0
                    else:
                        py[i,j] = self.z[j, i]/px[i]
                cdfTemp = stats.cdf(self.y, py[i, :])
                for j in xrange(len(cdfTemp)):
                    cdfY[i,j] = cdfTemp[j]
        except IndexError:
            self.logger.debug("i = %s"%str(i))
            self.logger.debug("j = %s"%str(j))
            self.logger.debug("p_y[%s, %s] = %s"%(str(i), str(j), str(py[i, j])))
            self.logger.debug("z[%s, %s] = %s"%(str(i), str(j), str(self.z[j, i])))
            self.logger.debug("p_x[%s] = %s"%(str(i), str(px[i])))
            self.logger.debug("cdfy dim = %s"%(str(cdfY.shape)))
            self.logger.debug("p_y dim = %s"%(str(py.shape)))
            self.logger.debug("cdfx dim = %s"%(str(cdfX.shape)))
            self.logger.debug("p_x dim = %s"%(str(px.shape)))

            raise

        self.cdfX = cdfX
        self.cdfY = cdfY
        return
